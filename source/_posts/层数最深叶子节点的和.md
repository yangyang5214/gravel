---
title: 层数最深叶子节点的和
tags: ['leetcode']
date: 2020-01-26 05:13:40
---


https://leetcode-cn.com/problems/deepest-leaves-sum/


给你一棵二叉树，请你返回层数最深的叶子节点的和。

![1483_ex1.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png)

```
输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
输出：15
```


### java

看了一遍递归，但是还是没思路😑最后参考的。。。


![](https://beer-1256523277.cos.ap-shanghai.myqcloud.com/blog/20200126211053.png)


```
public class DeepestLeavesSum {


public static void main(String[] args) {
DeepestLeavesSum deepestLeavesSum = new DeepestLeavesSum();
System.out.println(deepestLeavesSum.deepestLeavesSum(deepestLeavesSum.buildData()));
}

public int deepestLeavesSum(TreeNode root) {
return dfs(root, 1, getMaxDeep(root));
}

public TreeNode buildData() {
TreeNode root = new TreeNode(1);

TreeNode l4 = new TreeNode(4);
l4.left = new TreeNode(7);

TreeNode l2 = new TreeNode(2);
l2.left = l4;
l2.right = new TreeNode(5);

TreeNode r3 = new TreeNode(3);
TreeNode r6 = new TreeNode(6);
TreeNode r8 = new TreeNode(8);
r3.right = r6;
r6.right = r8;

root.left = l2;
root.right = r3;

return root;
}


public int dfs(TreeNode treeNode, int currentH, int h) {
if (treeNode == null) {
return 0;
}
if (currentH == h) {
return treeNode.val;
}
return dfs(treeNode.left, currentH + 1, h) + dfs(treeNode.right, currentH + 1, h);
}


public int getMaxDeep(TreeNode treeNode) {
if (treeNode == null) {
return 0;
}
int left = getMaxDeep(treeNode.left);
int right = getMaxDeep(treeNode.right);
return Math.max(left, right) + 1;
}
}

```
